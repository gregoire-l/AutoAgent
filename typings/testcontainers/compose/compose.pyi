"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from functools import cached_property
from os import PathLike
from typing import Any, Callable, Literal, Optional, TypeVar, Union
from urllib.error import HTTPError, URLError
from testcontainers.core.waiting_utils import wait_container_is_ready

_IPT = TypeVar("_IPT")
_WARNINGS = ...
@dataclass
class PublishedPort:
    """
    Class that represents the response we get from compose when inquiring status
    via `DockerCompose.get_running_containers()`.
    """
    URL: Optional[str] = ...
    TargetPort: Optional[str] = ...
    PublishedPort: Optional[str] = ...
    Protocol: Optional[str] = ...
    def normalize(self): # -> PublishedPort | Self:
        ...
    


OT = TypeVar("OT")
def get_only_element_or_raise(array: list[OT], exception: Callable[[], Exception]) -> OT:
    ...

@dataclass
class ComposeContainer:
    """
    A container class that represents a container managed by compose.
    It is not a true testcontainers.core.container.DockerContainer,
    but you can use the id with DockerClient to get that one too.
    """
    ID: Optional[str] = ...
    Name: Optional[str] = ...
    Command: Optional[str] = ...
    Project: Optional[str] = ...
    Service: Optional[str] = ...
    State: Optional[str] = ...
    Health: Optional[str] = ...
    ExitCode: Optional[str] = ...
    Publishers: list[PublishedPort] = ...
    def __post_init__(self): # -> None:
        ...
    
    def get_publisher(self, by_port: Optional[int] = ..., by_host: Optional[str] = ..., prefer_ip_version: Literal["IPV4", "IPv6"] = ...) -> PublishedPort:
        ...
    


@dataclass
class DockerCompose:
    """
    Manage docker compose environments.

    Args:
        context:
            The docker context. It corresponds to the directory containing
            the docker compose configuration file.
        compose_file_name:
            Optional. File name of the docker compose configuration file.
            If specified, you need to also specify the overrides if any.
        pull:
            Pull images before launching environment.
        build:
            Run `docker compose build` before running the environment.
        wait:
            Wait for the services to be healthy
            (as per healthcheck definitions in the docker compose configuration)
        env_file:
            Path to an '.env' file containing environment variables
            to pass to docker compose.
        services:
            The list of services to use from this DockerCompose.
        client_args:
            arguments to pass to docker.from_env()

    Example:

        This example spins up chrome and firefox containers using docker compose.

        .. doctest::

            >>> from testcontainers.compose import DockerCompose

            >>> compose = DockerCompose("compose/tests", compose_file_name="docker-compose-4.yml",
            ...                         pull=True)
            >>> with compose:
            ...     stdout, stderr = compose.get_logs()
            >>> b"Hello from Docker!" in stdout
            True

        .. code-block:: yaml

            services:
              hello-world:
                image: "hello-world"
    """
    context: Union[str, PathLike]
    compose_file_name: Optional[Union[str, list[str]]] = ...
    pull: bool = ...
    build: bool = ...
    wait: bool = ...
    keep_volumes: bool = ...
    env_file: Optional[str] = ...
    services: Optional[list[str]] = ...
    docker_command_path: Optional[str] = ...
    profiles: Optional[list[str]] = ...
    def __post_init__(self): # -> None:
        ...
    
    def __enter__(self) -> DockerCompose:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        ...
    
    def docker_compose_command(self) -> list[str]:
        """
        Returns command parts used for the docker compose commands

        Returns:
            cmd: Docker compose command parts.
        """
        ...
    
    @cached_property
    def compose_command_property(self) -> list[str]:
        ...
    
    def start(self) -> None:
        """
        Starts the docker compose environment.
        """
        ...
    
    def stop(self, down=...) -> None:
        """
        Stops the docker compose environment.
        """
        ...
    
    def get_logs(self, *services: str) -> tuple[str, str]:
        """
        Returns all log output from stdout and stderr of a specific container.

        :param services: which services to get the logs for (or omit, for all)

        Returns:
            stdout: Standard output stream.
            stderr: Standard error stream.
        """
        ...
    
    def get_config(self, *, path_resolution: bool = ..., normalize: bool = ..., interpolate: bool = ...) -> dict[str, Any]:
        """
        Parse, resolve and returns compose file via `docker config --format json`.
        In case of multiple compose files, the returned value will be a merge of all files.

        See: https://docs.docker.com/reference/cli/docker/compose/config/ for more details

        :param path_resolution: whether to resolve file paths
        :param normalize: whether to normalize compose model
        :param interpolate: whether to interpolate environment variables

        Returns:
            Compose file

        """
        ...
    
    def get_containers(self, include_all=...) -> list[ComposeContainer]:
        """
        Fetch information about running containers via `docker compose ps --format json`.
        Available only in V2 of compose.

        Returns:
            The list of running containers.

        """
        ...
    
    def get_container(self, service_name: Optional[str] = ..., include_all: bool = ...) -> ComposeContainer:
        ...
    
    def exec_in_container(self, command: list[str], service_name: Optional[str] = ...) -> tuple[str, str, int]:
        """
        Executes a command in the container of one of the services.

        Args:
            service_name: Name of the docker compose service to run the command in.
        command: Command to execute.

        :param service_name: specify the service name
        :param command: the command to run in the container

        Returns:
            stdout: Standard output stream.
            stderr: Standard error stream.
            exit_code: The command's exit code.
        """
        ...
    
    def get_service_port(self, service_name: Optional[str] = ..., port: Optional[int] = ...): # -> str | None:
        """
        Returns the mapped port for one of the services.

        Parameters
        ----------
        service_name: str
            Name of the docker compose service
        port: int
            The internal port to get the mapping for

        Returns
        -------
        str:
            The mapped port on the host
        """
        ...
    
    def get_service_host(self, service_name: Optional[str] = ..., port: Optional[int] = ...): # -> str | None:
        """
        Returns the host for one of the services.

        Parameters
        ----------
        service_name: str
            Name of the docker compose service
        port: int
            The internal port to get the host for

        Returns
        -------
        str:
            The hostname for the service
        """
        ...
    
    def get_service_host_and_port(self, service_name: Optional[str] = ..., port: Optional[int] = ...): # -> tuple[str | None, str | None]:
        ...
    
    @wait_container_is_ready(HTTPError, URLError)
    def wait_for(self, url: str) -> DockerCompose:
        """
        Waits for a response from a given URL. This is typically used to block until a service in
        the environment has started and is responding. Note that it does not assert any sort of
        return code, only check that the connection was successful.

        Args:
            url: URL from one of the services in the environment to use to wait on.
        """
        ...
    


